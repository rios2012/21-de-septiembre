

<html lang="es">
<head>  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flor interactiva</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgb(203, 243, 192);
      font-family: Arial, sans-serif;
      color: #fff;
      user-select: none;
// función para actualizar tamaño
function resizeCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    W = canvas.width;
    H = canvas.height;
    baseX = W / 2;
    baseY = H - 40;
    canStartPos.x = 100;
    canStartPos.y = H - 150;
    if(!dragging){
      canPos.x = canStartPos.x;
      canPos.y = canStartPos.y;
    }
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

function animate(){
  updatePhysics();
  drawScene();
  requestAnimationFrame(animate);
}

function updatePhysics(){
  stemTarget = 40 + stage * 40;
  if (watering) {
    waterTimer++;
    if (waterTimer > 28) { watering = false; waterTimer = 0; }
  }
  stemCurrent += (stemTarget - stemCurrent) * 0.12;
  let leafGoal = (stage >= 1) ? 1 : 0;
  leafOpacity += (leafGoal - leafOpacity) * 0.12;
  let petalGoal = (stage >= 4) ? 1 : Math.max(0,(stage-3)/(MAX_STAGES-3));
  petalScale += (petalGoal - petalScale)*0.1;
  blossomOpen += (petalScale - blossomOpen)*0.08;

  if (canPos.x > baseX-80 && canPos.x < baseX+80 &&
      canPos.y > baseY - stemCurrent - 120 && canPos.y < baseY){
    if (!watering) doWater();
  }
}

function drawScene(){
  ctx.clearRect(0,0,W,H);

  // suelo
  const grad = ctx.createLinearGradient(0,H-120,0,H);
  grad.addColorStop(0,'rgba(0,0,0,0.4)');
  grad.addColorStop(1,'rgba(0,0,0,0.8)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,H-120,W,120);
  ctx.strokeStyle = "#233"; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, baseY+6); ctx.lineTo(W, baseY+6); ctx.stroke();

  // flor
  drawStem(baseX, baseY, stemCurrent*scaleFactor);
  if (leafOpacity > 0.02) drawLeaves(baseX, baseY, stemCurrent*scaleFactor, leafOpacity);
  if (stage < 4) drawBud(baseX, baseY-stemCurrent*scaleFactor);
  if (stage > 2) drawFlower(baseX, baseY-stemCurrent*scaleFactor, blossomOpen);

  // regadera
  drawWaterCan(ctx, canPos.x, canPos.y, 1.0, watering);
  if (mostrarMensajeCentral) {
    ctx.save();
    ctx.font = "bold 38px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#ff69b4";
    ctx.shadowBlur = 18;
    ctx.globalAlpha = 0.95;
    const lineas = mensajeCentral.split('\n');
    ctx.fillText(lineas[0], W/2, H/2 - 20);
    if(lineas[1]) {
      ctx.font = "28px Arial";
      ctx.fillText(lineas[1], W/2, H/2 + 20);
    }
    ctx.restore();
  }
}

function drawFlower(x,y,openFactor){
  ctx.save(); ctx.translate(x,y);
  const petals=8, petalMaxRadius=62*scaleFactor, petalSize=36*scaleFactor, spread=openFactor;
  petalHitboxes = []; // limpiar zonas

  for(let i=0;i<petals;i++){
    const ang=(Math.PI*2/petals)*i;
    const rx=Math.cos(ang)*(20+petalMaxRadius*spread);
    const ry=Math.sin(ang)*(12+petalMaxRadius*spread*0.9);
    ctx.save(); ctx.translate(rx,ry);
    ctx.rotate(ang+Math.PI/8*(1-spread));
    // Cambia el gradiente a tonos amarillos
    const g=ctx.createLinearGradient(-petalSize,0,petalSize,0);
    g.addColorStop(0,"#fff700");   // Amarillo claro
    g.addColorStop(0.6,"#ffe066"); // Amarillo medio
    g.addColorStop(1,"#ffd700");   // Amarillo oro
    ctx.fillStyle=g;
    ctx.beginPath(); ctx.ellipse(0,0,petalSize*(0.6+0.4*spread),petalSize*(1.1-0.2*spread),0,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // guardar área clicable ⬅️ añadido
    petalHitboxes.push({x:x+rx, y:y+ry, r:petalSize, index:i});
  }

  const baseCenter = 20;
  const maxCenter = 50;
  const centerR = (baseCenter + (maxCenter - baseCenter) * blossomOpen) * scaleFactor;
  ctx.beginPath(); ctx.fillStyle="#e6b800";
  ctx.ellipse(-10+10*openFactor,6*openFactor,centerR,centerR*0.95,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// detectar clic en pétalos
canvas.addEventListener("click", ev=>{
  if(stage < MAX_STAGES) return; // solo cuando la flor está completa
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
  for(let p of petalHitboxes){
    const dx = mx - p.x, dy = my - p.y;
    if(dx*dx+dy*dy < (p.r*0.8)*(p.r*0.8)){ // dentro del pétalo
      openPetal(p.index);
      break;
    }
  }
});
canvas.addEventListener("click", ev => {
  if(stage < MAX_STAGES) return; // Solo cuando la flor está completa
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
  // Centro de la flor
  const centroX = baseX, centroY = baseY - stemCurrent * scaleFactor;
  const dist = Math.hypot(mx - centroX, my - centroY);
  if (dist < 60) { // Ajusta el radio si lo deseas
    mensajeCentral = "Feliz 21 de septiembre 💕\nGracias por estar en mi vida";
    mostrarMensajeCentral = true;
    mainSong.currentTime = 0;
    mainSong.play();
    
  }
});
canvas.addEventListener("click", ev => {
  if (!mostrarMensajeCentral) return;
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
  // Centro de la flor
  const centroX = baseX, centroY = baseY - stemCurrent * scaleFactor;
  const dist = Math.hypot(mx - centroX, my - centroY);
  if (dist >= 60) { // Si el clic NO es en el centro
    mostrarMensajeCentral = false;
    mainSong.pause();
    mainSong.currentTime = 0;
  }
});

function openPetal(index){
  const data = petalData[index];
  bigImage.src = data.img;
  overlay.classList.add("show");

  // Mostrar la frase debajo de la imagen
  document.getElementById("overlayText").textContent = data.text || "";

  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

function drawStem(x,groundY,height){
  const topY = groundY-height;
  ctx.save();
  ctx.lineWidth=14*scaleFactor; ctx.strokeStyle="#0a3b12"; ctx.lineCap="round";
  ctx.beginPath(); ctx.moveTo(x+6*scaleFactor,groundY);
  ctx.bezierCurveTo(x+18*scaleFactor,groundY-height*0.3, x-18*scaleFactor,topY+height*0.4, x+2*scaleFactor,topY);
  ctx.stroke();
  ctx.strokeStyle="#17a12f"; ctx.lineWidth=10*scaleFactor;
  ctx.beginPath(); ctx.moveTo(x,groundY);
  ctx.bezierCurveTo(x+12*scaleFactor,groundY-height*0.28, x-12*scaleFactor,topY+height*0.38, x,topY);
  ctx.stroke(); ctx.restore();

}

function drawLeaves(x,groundY,height,opacity){
  ctx.save(); ctx.globalAlpha=0.75*opacity;
  ctx.fillStyle="#0f8b3f";
  ctx.beginPath();
  ctx.moveTo(x-6,groundY-Math.round(height*0.4));
  ctx.bezierCurveTo(x-120*scaleFactor,groundY-Math.round(height*0.55),
                    x-80*scaleFactor,groundY-Math.round(height*0.1),
                    x+2,groundY-Math.round(height*0.2));
  ctx.fill();
  ctx.fillStyle="#18b24e";
  ctx.beginPath();
  ctx.moveTo(x+6,groundY-Math.round(height*0.55));
  ctx.bezierCurveTo(x+120*scaleFactor,groundY-Math.round(height*0.75),
                    x+80*scaleFactor,groundY-Math.round(height*0.25),
                    x+2,groundY-Math.round(height*0.35));
  ctx.fill(); ctx.restore();
}

function drawBud(x,y){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle="#ffe066"; // Amarillo para el capullo exterior
  const s=18+(stage*6);
  const scaledS = s*scaleFactor;
  ctx.beginPath(); ctx.ellipse(0,0,scaledS*0.9,scaledS*1.3,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#111"; // Negro para el centro del capullo
  ctx.beginPath(); ctx.ellipse(0,0,Math.max(6,scaledS*0.4),Math.max(6,scaledS*0.4),0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// drag regadera
canvas.addEventListener('mousedown', ev=>{
  const rect=canvas.getBoundingClientRect();
  const mx=ev.clientX-rect.left, my=ev.clientY-rect.top;
  if(mx>=canPos.x && mx<=canPos.x+canPos.w && my>=canPos.y && my<=canPos.y+canPos.h){
    dragging=true; offsetX=mx-canPos.x; offsetY=my-canPos.y;
  }
});
canvas.addEventListener('mousemove', ev=>{
  if(dragging){ const rect=canvas.getBoundingClientRect();
    canPos.x=ev.clientX-rect.left-offsetX;
    canPos.y=ev.clientY-rect.top-offsetY;
  }
});
canvas.addEventListener('mouseup', ()=>{ dragging=false; returnCanToStart(); });
canvas.addEventListener('mouseleave', ()=>{ dragging=false; returnCanToStart(); });
// Eventos táctiles para móviles
canvas.addEventListener('touchstart', ev => {
  const rect = canvas.getBoundingClientRect();
  const touch = ev.touches[0];
  const mx = touch.clientX - rect.left, my = touch.clientY - rect.top;
  if(mx >= canPos.x && mx <= canPos.x + canPos.w && my >= canPos.y && my <= canPos.y + canPos.h){
    dragging = true; offsetX = mx - canPos.x; offsetY = my - canPos.y;
    ev.preventDefault();
  }
});
canvas.addEventListener('touchmove', ev => {
  if(dragging){
    const rect = canvas.getBoundingClientRect();
    const touch = ev.touches[0];
    canPos.x = touch.clientX - rect.left - offsetX;
    canPos.y = touch.clientY - rect.top - offsetY;
    ev.preventDefault();
  }
});
canvas.addEventListener('touchend', () => { dragging = false; returnCanToStart(); });
canvas.addEventListener('touchcancel', () => { dragging = false; returnCanToStart(); });

function returnCanToStart(){
  const anim = setInterval(()=>{
    const dx = canStartPos.x - canPos.x;
    const dy = canStartPos.y - canPos.y;
    if(Math.abs(dx)<1 && Math.abs(dy)<1){
      canPos.x = canStartPos.x;
      canPos.y = canStartPos.y;
      clearInterval(anim);
    } else {
      canPos.x += dx*0.2;
      canPos.y += dy*0.2;
    }
  }, 16);
}

animate();
</script>
</body>
</html>

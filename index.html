<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Flor interactiva (fix m√≥viles)</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgb(203, 243, 192);
      font-family: Arial, sans-serif;
      color:#fff;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action:none; /* evita scroll/zoom en gestos */
      overscroll-behavior:none;
      overflow:hidden;
    }
    canvas{
      display:block;
      background: rgb(179, 236, 165);
      border-radius:8px;
      box-shadow: 0 6px 25px rgba(0,0,0,0.7);
      touch-action:none; /* pointer events consistentes */
    }
    /* Overlay para mostrar imagen ampliada */
    #overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,0.85);
      display:flex; align-items:center; justify-content:center; flex-direction:column;
      visibility:hidden; opacity:0; transition:opacity .3s ease;
      z-index: 10;
    }
    #overlay.show{ visibility:visible; opacity:1; }
    #overlay img{ max-width:80%; max-height:70%; border-radius:12px; box-shadow:0 0 20px rgba(255,255,255,.8); }
    #overlayText{ margin-top:20px; color:#fff; font-size:1.3em; text-align:center; width:100%; padding: 0 16px; }
    .hidden{ display:none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Audio principal y de p√©talos (un solo elemento para evitar solapes) -->
  <audio id="mainSong" src="principal.mp3" preload="auto" playsinline class="hidden"></audio>
  <audio id="petalAudio" preload="auto" playsinline class="hidden"></audio>

  <!-- Overlay para im√°genes -->
  <div id="overlay" aria-hidden="true">
    <img id="bigImage" alt="Imagen del p√©talo" />
    <div id="overlayText"></div>
  </div>

<script>
/* =====================
   Estado y utilidades
   ===================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
let baseX = W/2, baseY = H - 40;

// Crecimiento
const MAX_STAGES = 6;
let stage = 0, watering = false, waterTimer = 0;
let stemCurrent = 40, stemTarget = 40;
let leafOpacity = 0, petalScale = 0, blossomOpen = 0;

// Regadera
let canPos = { x: 100, y: H - 150, w: 120, h: 90 };
const canStartPos = { x: 100, y: H - 150 };
let dragging = false, offsetX = 0, offsetY = 0;
let canAngle = 0;
let returnAnim = null; // para evitar m√∫ltiples intervals

const scaleFactor = 1.4;

// Recursos de p√©talos
const petalData = [
  {img:"img1.jpg", audio:"audio1.mp3", text:"Eres mi inspiraci√≥n üíñ"},
  {img:"img2.jpg", audio:"audio2.mp3", text:"Contigo todo es mejor üåπ"},
  {img:"img3.jpg", audio:"audio3.mp3", text:"Eres mi felicidad ‚ú®"},
  {img:"img4.jpg", audio:"audio4.mp3", text:"Gracias por existir üíï"},
  {img:"img5.jpg", audio:"audio5.mp3", text:"Nuestro amor florece üå∏"},
  {img:"img6.jpg", audio:"audio6.mp3", text:"Eres mi sol ‚òÄÔ∏è"},
  {img:"img7.jpg", audio:"audio7.mp3", text:"Te quiero infinito üí´"},
  {img:"img8.jpg", audio:"audio8.mp3", text:"Eres mi todo ‚ù§Ô∏è"}
];

let petalHitboxes = []; // zonas clicables
let mostrarMensajeCentral = false;
let mensajeCentral = "";

const mainSong = document.getElementById('mainSong');
const petalAudio = document.getElementById('petalAudio');
const overlay = document.getElementById('overlay');
const bigImage = document.getElementById('bigImage');
const overlayText = document.getElementById('overlayText');
let overlayOpen = false;

// Pre-carga de im√°genes (evita ver la anterior pegada en m√≥viles)
const imageCache = new Map();
function preloadImages(data){
  data.forEach(({img})=>{
    const im = new Image();
    im.decoding = 'async';
    im.loading = 'eager';
    im.src = img;
    imageCache.set(img, im);
  });
}
preloadImages(petalData);

// Pre-carga ligera de audios (sin reproducir)
function warmAudio(src){
  // alterna src para forzar precarga controlada
  const a = document.createElement('audio');
  a.preload = 'metadata';
  a.src = src;
}
petalData.forEach(p=>warmAudio(p.audio));

// Evitar reproducir dos audios a la vez
function stopAllAudio(){
  [mainSong, petalAudio].forEach(a=>{ try{ a.pause(); a.currentTime = 0; }catch(_){} });
}

// iOS/Safari: desbloquear audio en primer gesto
let audioUnlocked = false;
function unlockAudio(){
  if(audioUnlocked) return;
  try { mainSong.play().then(()=>{ mainSong.pause(); mainSong.currentTime = 0; audioUnlocked = true; }).catch(()=>{}); } catch(_){}
}

/* =====================
   Redimensionado
   ===================== */
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  W = canvas.width; H = canvas.height;
  baseX = W/2; baseY = H - 40;
  canStartPos.x = 0.10; canStartPos.y = H - 150;
  if(!dragging){ canPos.x = canStartPos.x; canPos.y = canStartPos.y; }
}
window.addEventListener('resize', resizeCanvas, { passive: true });
resizeCanvas();

/* =====================
   Animaci√≥n principal
   ===================== */
function animate(){ updatePhysics(); drawScene(); requestAnimationFrame(animate); }

function updatePhysics(){
  stemTarget = 40 + stage * 40;
  if (watering) {
    waterTimer++;
    if (waterTimer > 28) { watering = false; waterTimer = 0; }
  }
  stemCurrent += (stemTarget - stemCurrent) * 0.12;
  let leafGoal = (stage >= 1) ? 1 : 0;
  leafOpacity += (leafGoal - leafOpacity) * 0.12;
  let petalGoal = (stage >= 4) ? 1 : Math.max(0,(stage-3)/(MAX_STAGES-3));
  petalScale += (petalGoal - petalScale)*0.1;
  blossomOpen += (petalScale - blossomOpen)*0.08;

  // zona de riego
  if (canPos.x > baseX-80 && canPos.x < baseX+80 &&
      canPos.y > baseY - stemCurrent - 120 && canPos.y < baseY){
    if (!watering) doWater();
  }
}

function drawScene(){
  ctx.clearRect(0,0,W,H);
  // suelo
  const grad = ctx.createLinearGradient(0,H-120,0,H);
  grad.addColorStop(0,'rgba(0,0,0,0.4)');
  grad.addColorStop(1,'rgba(0,0,0,0.8)');
  ctx.fillStyle = grad; ctx.fillRect(0,H-120,W,120);
  ctx.strokeStyle = '#233'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, baseY+6); ctx.lineTo(W, baseY+6); ctx.stroke();

  // flor
  drawStem(baseX, baseY, stemCurrent*scaleFactor);
  if (leafOpacity > 0.02) drawLeaves(baseX, baseY, stemCurrent*scaleFactor, leafOpacity);
  if (stage < 4) drawBud(baseX, baseY-stemCurrent*scaleFactor);
  if (stage > 2) drawFlower(baseX, baseY-stemCurrent*scaleFactor, blossomOpen);

  // regadera
  drawWaterCan(ctx, canPos.x, canPos.y, 1.0, watering);

  // mensaje central
  if (mostrarMensajeCentral) {
    ctx.save();
      // üì± Ajustar tama√±o din√°mico seg√∫n pantalla
  let fontSizeMain = Math.min(W, H) * 0.06;  // 6% del lado menor
  let fontSizeSub  = Math.min(W, H) * 0.045; // 4.5% del lado menor
   ctx.font = `bold ${fontSizeMain}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#ff69b4';
    ctx.shadowBlur = 18;
    ctx.globalAlpha = 0.95;
    const lineas = mensajeCentral.split('\n');
    ctx.fillText(lineas[0], W/2, H/2 - 20);
    if(lineas[1]) { ctx.font = '28px Arial'; ctx.fillText(lineas[1], W/2, H/2 + 20); }
    ctx.restore();
  }
}

function drawFlower(x,y,openFactor){
  ctx.save(); ctx.translate(x,y);
  const petals=8, petalMaxRadius=62*scaleFactor, petalSize=36*scaleFactor, spread=openFactor;
  petalHitboxes = []; // limpiar zonas
  for(let i=0;i<petals;i++){
    const ang=(Math.PI*2/petals)*i;
    const rx=Math.cos(ang)*(20+petalMaxRadius*spread);
    const ry=Math.sin(ang)*(12+petalMaxRadius*spread*0.9);
    ctx.save(); ctx.translate(rx,ry);
    ctx.rotate(ang+Math.PI/8*(1-spread));
    const g=ctx.createLinearGradient(-petalSize,0,petalSize,0);
    g.addColorStop(0,'#fff700');
    g.addColorStop(0.6,'#ffe066');
    g.addColorStop(1,'#ffd700');
    ctx.fillStyle=g;
    ctx.beginPath(); ctx.ellipse(0,0,petalSize*(0.6+0.4*spread),petalSize*(1.1-0.2*spread),0,0,Math.PI*2); ctx.fill();
    ctx.restore();
    petalHitboxes.push({x:x+rx, y:y+ry, r:petalSize, index:i});
  }
  const baseCenter = 20; const maxCenter = 50;
  const centerR = (baseCenter + (maxCenter - baseCenter) * blossomOpen) * scaleFactor;
  ctx.beginPath(); ctx.fillStyle='#e6b800';
  ctx.ellipse(-10+10*openFactor,6*openFactor,centerR,centerR*0.95,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* =====================
   Interacci√≥n (unificado)
   ===================== */
function withinCan(mx,my){
  return (mx>=canPos.x && mx<=canPos.x+canPos.w && my>=canPos.y && my<=canPos.y+canPos.h);
}

function handlePointerDown(ev){
  unlockAudio();
  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX ?? ev.touches?.[0]?.clientX) - rect.left;
  const my = (ev.clientY ?? ev.touches?.[0]?.clientY) - rect.top;
  if(withinCan(mx,my)){
    dragging = true; offsetX = mx - canPos.x; offsetY = my - canPos.y;
    ev.preventDefault();
  }
}

function handlePointerMove(ev){
  if(dragging){
    const rect = canvas.getBoundingClientRect();
    const touch = ev.touches?.[0];
    const cx = (touch? touch.clientX : ev.clientX) - rect.left;
    const cy = (touch? touch.clientY : ev.clientY) - rect.top;
    canPos.x = cx - offsetX; canPos.y = cy - offsetY;
    ev.preventDefault();
  }
}

function handlePointerUp(){ dragging = false; returnCanToStart(); }

function handleTap(ev){
  // L√≥gica en un solo handler para evitar triple-disparo en m√≥viles
  if(stage < MAX_STAGES && !mostrarMensajeCentral) return; // solo cuando est√° completa o est√° el mensaje

  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX ?? ev.changedTouches?.[0]?.clientX) - rect.left;
  const my = (ev.clientY ?? ev.changedTouches?.[0]?.clientY) - rect.top;

  // Si hay mensaje central, click fuera del centro lo cierra
  const centroX = baseX, centroY = baseY - stemCurrent * scaleFactor;
  const dist = Math.hypot(mx - centroX, my - centroY);

  if(mostrarMensajeCentral){
    if (dist >= 60){ // clic fuera
      mostrarMensajeCentral = false; stopAllAudio();
    }
    return;
  }

  // Primero detecta si tocaron el centro
  if (dist < 60){
    mensajeCentral = 'Feliz 21 de septiembre üíï\nGracias por estar en mi vida';
    mostrarMensajeCentral = true;
    stopAllAudio();
    mainSong.currentTime = 0;
    mainSong.play().catch(()=>{});
    return;
  }

  // Luego, verifica p√©talos
   const hitboxFactor = 2.5; // √°rea t√°ctil grande para m√≥viles
  let petalCercano = null;
  let menorDist = Infinity;
  for(const p of petalHitboxes){
    const dx = mx - p.x, dy = my - p.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < p.r * hitboxFactor && dist < menorDist){
      menorDist = dist;
      petalCercano = p;
    }
  }
  if(petalCercano){
    openPetal(petalCercano.index);
  }
}

canvas.addEventListener('mousedown', handlePointerDown, { passive:false });
canvas.addEventListener('mousemove', handlePointerMove, { passive:false });
window.addEventListener('mouseup', handlePointerUp, { passive:true });

canvas.addEventListener('touchstart', handlePointerDown, { passive:false });
canvas.addEventListener('touchmove', handlePointerMove, { passive:false });
canvas.addEventListener('touchend', (e)=>{ handlePointerUp(e); handleTap(e); }, { passive:false });
canvas.addEventListener('click', handleTap, { passive:true });

// Cerrar overlay con tap/click
overlay.addEventListener('click', ()=>{
  hideOverlay();
});

/* =====================
   Acciones
   ===================== */
function openPetal(index){
  const data = petalData[index];
  // Asegurar que no quede la imagen anterior visible por el fade
    hideOverlay();
  overlayText.textContent = '';
  bigImage.src = '';

  const im = imageCache.get(data.img) || new Image();
  if(!imageCache.has(data.img)){ im.src = data.img; }

  // Mostrar overlay solo cuando la imagen est√° lista (evita "imagen anterior pegada")
  im.decode?.().then(()=>{
    bigImage.src = im.src;
    overlayText.textContent = data.text || '';
    showOverlay();
  }).catch(()=>{
    // Fallback si decode no est√°
    bigImage.onload = ()=>{ showOverlay(); };
    bigImage.src = data.img;
    overlayText.textContent = data.text || '';
  });

  // Audio del p√©talo (un solo elemento y en orden)
  stopAllAudio();
  petalAudio.src = data.audio;
  petalAudio.currentTime = 0;
  petalAudio.play().catch(()=>{ /* Algunos navegadores requieren otro gesto */ });
}

function showOverlay(){
  overlay.classList.add('show');
  overlay.setAttribute('aria-hidden', 'false');
  overlayOpen = true;
}
function hideOverlay(){
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden', 'true');
  overlayOpen = false;
  stopAllAudio();
}

function doWater(){
  if(stage<MAX_STAGES){ stage+=1; }
  watering=true; waterTimer=0;
}

function returnCanToStart(){
  if(returnAnim) { clearInterval(returnAnim); returnAnim = null; }
  returnAnim = setInterval(()=>{
    const dx = canStartPos.x - canPos.x;
    const dy = canStartPos.y - canPos.y;
    if(Math.abs(dx)<1 && Math.abs(dy)<1){
      canPos.x = canStartPos.x; canPos.y = canStartPos.y;
      clearInterval(returnAnim); returnAnim = null;
    } else { canPos.x += dx*0.2; canPos.y += dy*0.2; }
  }, 16);
}

/* =====================
   Dibujo de elementos
   ===================== */
function drawWaterCan(ctx,x,y,scale=1,tipping=false){
  ctx.save(); ctx.translate(x,y);
  const targetAngle = tipping ? -0.25 : 0;
  canAngle += (targetAngle - canAngle)*0.1;
  ctx.rotate(canAngle); ctx.scale(scale,scale);
  ctx.fillStyle='#b0c4de';
  roundRect(ctx,0,20,80,48,8,true,false);
  ctx.beginPath(); ctx.moveTo(78,34); ctx.bezierCurveTo(110,18,110,34,78,54); ctx.fill();
  ctx.strokeStyle='#9aa9b8'; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(18,16,22,-1.2,0.8); ctx.stroke();
  ctx.restore();
  if (tipping){
    const mouthX = x+95, mouthY = y+25;
    for(let i=0;i<12;i++){
      const spread = (i-6)*0.08;
      const dx = mouthX + Math.cos(spread)*(Math.random()*20);
      const dropSpeed = 120;
      const dy = mouthY + i*10 + (Date.now()/dropSpeed % 100);
      ctx.beginPath(); ctx.fillStyle='rgba(150,200,255,0.9)';
      ctx.ellipse(dx, dy, 3, 8, Math.PI/6, 0, Math.PI*2); ctx.fill();
    }
  }
}

function roundRect(ctx,x,y,w,h,r,fill=true,stroke=true){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y, x+w,y+h, r);
  ctx.arcTo(x+w,y+h, x,y+h, r);
  ctx.arcTo(x,y+h, x,y, r);
  ctx.arcTo(x,y, x+w,y, r);
  ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke();
}

function drawStem(x,groundY,height){
  const topY = groundY-height; ctx.save();
  ctx.lineWidth=14*scaleFactor; ctx.strokeStyle='#0a3b12'; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(x+6*scaleFactor,groundY);
  ctx.bezierCurveTo(x+18*scaleFactor,groundY-height*0.3, x-18*scaleFactor,topY+height*0.4, x+2*scaleFactor,topY); ctx.stroke();
  ctx.strokeStyle='#17a12f'; ctx.lineWidth=10*scaleFactor;
  ctx.beginPath(); ctx.moveTo(x,groundY);
  ctx.bezierCurveTo(x+12*scaleFactor,groundY-height*0.28, x-12*scaleFactor,topY+height*0.38, x,topY); ctx.stroke();
  ctx.restore();
}

function drawLeaves(x,groundY,height,opacity){
  ctx.save(); ctx.globalAlpha=0.75*opacity; ctx.fillStyle='#0f8b3f';
  ctx.beginPath(); ctx.moveTo(x-6,groundY-Math.round(height*0.4));
  ctx.bezierCurveTo(x-120*scaleFactor,groundY-Math.round(height*0.55), x-80*scaleFactor,groundY-Math.round(height*0.1), x+2,groundY-Math.round(height*0.2)); ctx.fill();
  ctx.fillStyle='#18b24e'; ctx.beginPath(); ctx.moveTo(x+6,groundY-Math.round(height*0.55));
  ctx.bezierCurveTo(x+120*scaleFactor,groundY-Math.round(height*0.75), x+80*scaleFactor,groundY-Math.round(height*0.25), x+2,groundY-Math.round(height*0.35)); ctx.fill();
  ctx.restore();
}

function drawBud(x,y){
  ctx.save(); ctx.translate(x,y); ctx.fillStyle='#ffe066';
  const s=18+(stage*6); const scaledS = s*scaleFactor;
  ctx.beginPath(); ctx.ellipse(0,0,scaledS*0.9,scaledS*1.3,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#111'; ctx.beginPath(); ctx.ellipse(0,0,Math.max(6,scaledS*0.4),Math.max(6,scaledS*0.4),0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

/* =====================
   Vida del documento
   ===================== */
// Pausar si cambia la pesta√±a (evita desorden de audio en m√≥viles)
window.addEventListener('visibilitychange', ()=>{ if(document.hidden){ stopAllAudio(); } });

animate();
</script>
</body>
</html>






